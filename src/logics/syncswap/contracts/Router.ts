/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from 'ethers';
import type { FunctionFragment, Result } from '@ethersproject/abi';
import type { Listener, Provider } from '@ethersproject/providers';
import type { TypedEventFilter, TypedEvent, TypedListener, OnEvent } from './common';

export declare namespace SyncSwapRouter {
  export type TokenInputStruct = { token: string; amount: BigNumberish };

  export type TokenInputStructOutput = [string, BigNumber] & {
    token: string;
    amount: BigNumber;
  };
}

export declare namespace IRouter {
  export type SplitPermitParamsStruct = {
    token: string;
    approveAmount: BigNumberish;
    deadline: BigNumberish;
    v: BigNumberish;
    r: BytesLike;
    s: BytesLike;
  };

  export type SplitPermitParamsStructOutput = [string, BigNumber, BigNumber, number, string, string] & {
    token: string;
    approveAmount: BigNumber;
    deadline: BigNumber;
    v: number;
    r: string;
    s: string;
  };

  export type ArrayPermitParamsStruct = {
    approveAmount: BigNumberish;
    deadline: BigNumberish;
    signature: BytesLike;
  };

  export type ArrayPermitParamsStructOutput = [BigNumber, BigNumber, string] & {
    approveAmount: BigNumber;
    deadline: BigNumber;
    signature: string;
  };

  export type SwapStepStruct = {
    pool: string;
    data: BytesLike;
    callback: string;
    callbackData: BytesLike;
  };

  export type SwapStepStructOutput = [string, string, string, string] & {
    pool: string;
    data: string;
    callback: string;
    callbackData: string;
  };

  export type SwapPathStruct = {
    steps: IRouter.SwapStepStruct[];
    tokenIn: string;
    amountIn: BigNumberish;
  };

  export type SwapPathStructOutput = [IRouter.SwapStepStructOutput[], string, BigNumber] & {
    steps: IRouter.SwapStepStructOutput[];
    tokenIn: string;
    amountIn: BigNumber;
  };
}

export declare namespace IPool {
  export type TokenAmountStruct = { token: string; amount: BigNumberish };

  export type TokenAmountStructOutput = [string, BigNumber] & {
    token: string;
    amount: BigNumber;
  };
}

export interface RouterInterface extends utils.Interface {
  functions: {
    'addLiquidity(address,(address,uint256)[],bytes,uint256,address,bytes)': FunctionFragment;
    'addLiquidity2(address,(address,uint256)[],bytes,uint256,address,bytes)': FunctionFragment;
    'addLiquidityWithPermit(address,(address,uint256)[],bytes,uint256,address,bytes,(address,uint256,uint256,uint8,bytes32,bytes32)[])': FunctionFragment;
    'addLiquidityWithPermit2(address,(address,uint256)[],bytes,uint256,address,bytes,(address,uint256,uint256,uint8,bytes32,bytes32)[])': FunctionFragment;
    'burnLiquidity(address,uint256,bytes,uint256[],address,bytes)': FunctionFragment;
    'burnLiquiditySingle(address,uint256,bytes,uint256,address,bytes)': FunctionFragment;
    'burnLiquiditySingleWithPermit(address,uint256,bytes,uint256,address,bytes,(uint256,uint256,bytes))': FunctionFragment;
    'burnLiquidityWithPermit(address,uint256,bytes,uint256[],address,bytes,(uint256,uint256,bytes))': FunctionFragment;
    'createPool(address,bytes)': FunctionFragment;
    'enteredPools(address,uint256)': FunctionFragment;
    'enteredPoolsLength(address)': FunctionFragment;
    'isPoolEntered(address,address)': FunctionFragment;
    'multicall(bytes[])': FunctionFragment;
    'selfPermit(address,uint256,uint256,uint8,bytes32,bytes32)': FunctionFragment;
    'selfPermit2(address,uint256,uint256,bytes)': FunctionFragment;
    'selfPermit2IfNecessary(address,uint256,uint256,bytes)': FunctionFragment;
    'selfPermitAllowed(address,uint256,uint256,uint8,bytes32,bytes32)': FunctionFragment;
    'selfPermitAllowedIfNecessary(address,uint256,uint256,uint8,bytes32,bytes32)': FunctionFragment;
    'selfPermitIfNecessary(address,uint256,uint256,uint8,bytes32,bytes32)': FunctionFragment;
    'stake(address,address,uint256,address)': FunctionFragment;
    'swap(((address,bytes,address,bytes)[],address,uint256)[],uint256,uint256)': FunctionFragment;
    'swapWithPermit(((address,bytes,address,bytes)[],address,uint256)[],uint256,uint256,(address,uint256,uint256,uint8,bytes32,bytes32))': FunctionFragment;
    'vault()': FunctionFragment;
    'wETH()': FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | 'addLiquidity'
      | 'addLiquidity2'
      | 'addLiquidityWithPermit'
      | 'addLiquidityWithPermit2'
      | 'burnLiquidity'
      | 'burnLiquiditySingle'
      | 'burnLiquiditySingleWithPermit'
      | 'burnLiquidityWithPermit'
      | 'createPool'
      | 'enteredPools'
      | 'enteredPoolsLength'
      | 'isPoolEntered'
      | 'multicall'
      | 'selfPermit'
      | 'selfPermit2'
      | 'selfPermit2IfNecessary'
      | 'selfPermitAllowed'
      | 'selfPermitAllowedIfNecessary'
      | 'selfPermitIfNecessary'
      | 'stake'
      | 'swap'
      | 'swapWithPermit'
      | 'vault'
      | 'wETH'
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: 'addLiquidity',
    values: [string, SyncSwapRouter.TokenInputStruct[], BytesLike, BigNumberish, string, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: 'addLiquidity2',
    values: [string, SyncSwapRouter.TokenInputStruct[], BytesLike, BigNumberish, string, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: 'addLiquidityWithPermit',
    values: [
      string,
      SyncSwapRouter.TokenInputStruct[],
      BytesLike,
      BigNumberish,
      string,
      BytesLike,
      IRouter.SplitPermitParamsStruct[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: 'addLiquidityWithPermit2',
    values: [
      string,
      SyncSwapRouter.TokenInputStruct[],
      BytesLike,
      BigNumberish,
      string,
      BytesLike,
      IRouter.SplitPermitParamsStruct[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: 'burnLiquidity',
    values: [string, BigNumberish, BytesLike, BigNumberish[], string, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: 'burnLiquiditySingle',
    values: [string, BigNumberish, BytesLike, BigNumberish, string, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: 'burnLiquiditySingleWithPermit',
    values: [string, BigNumberish, BytesLike, BigNumberish, string, BytesLike, IRouter.ArrayPermitParamsStruct]
  ): string;
  encodeFunctionData(
    functionFragment: 'burnLiquidityWithPermit',
    values: [string, BigNumberish, BytesLike, BigNumberish[], string, BytesLike, IRouter.ArrayPermitParamsStruct]
  ): string;
  encodeFunctionData(functionFragment: 'createPool', values: [string, BytesLike]): string;
  encodeFunctionData(functionFragment: 'enteredPools', values: [string, BigNumberish]): string;
  encodeFunctionData(functionFragment: 'enteredPoolsLength', values: [string]): string;
  encodeFunctionData(functionFragment: 'isPoolEntered', values: [string, string]): string;
  encodeFunctionData(functionFragment: 'multicall', values: [BytesLike[]]): string;
  encodeFunctionData(
    functionFragment: 'selfPermit',
    values: [string, BigNumberish, BigNumberish, BigNumberish, BytesLike, BytesLike]
  ): string;
  encodeFunctionData(functionFragment: 'selfPermit2', values: [string, BigNumberish, BigNumberish, BytesLike]): string;
  encodeFunctionData(
    functionFragment: 'selfPermit2IfNecessary',
    values: [string, BigNumberish, BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: 'selfPermitAllowed',
    values: [string, BigNumberish, BigNumberish, BigNumberish, BytesLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: 'selfPermitAllowedIfNecessary',
    values: [string, BigNumberish, BigNumberish, BigNumberish, BytesLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: 'selfPermitIfNecessary',
    values: [string, BigNumberish, BigNumberish, BigNumberish, BytesLike, BytesLike]
  ): string;
  encodeFunctionData(functionFragment: 'stake', values: [string, string, BigNumberish, string]): string;
  encodeFunctionData(functionFragment: 'swap', values: [IRouter.SwapPathStruct[], BigNumberish, BigNumberish]): string;
  encodeFunctionData(
    functionFragment: 'swapWithPermit',
    values: [IRouter.SwapPathStruct[], BigNumberish, BigNumberish, IRouter.SplitPermitParamsStruct]
  ): string;
  encodeFunctionData(functionFragment: 'vault', values?: undefined): string;
  encodeFunctionData(functionFragment: 'wETH', values?: undefined): string;

  decodeFunctionResult(functionFragment: 'addLiquidity', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'addLiquidity2', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'addLiquidityWithPermit', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'addLiquidityWithPermit2', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'burnLiquidity', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'burnLiquiditySingle', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'burnLiquiditySingleWithPermit', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'burnLiquidityWithPermit', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'createPool', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'enteredPools', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'enteredPoolsLength', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'isPoolEntered', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'multicall', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'selfPermit', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'selfPermit2', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'selfPermit2IfNecessary', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'selfPermitAllowed', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'selfPermitAllowedIfNecessary', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'selfPermitIfNecessary', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'stake', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'swap', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'swapWithPermit', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'vault', data: BytesLike): Result;
  decodeFunctionResult(functionFragment: 'wETH', data: BytesLike): Result;

  events: {};
}

export interface Router extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: RouterInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    addLiquidity(
      pool: string,
      inputs: SyncSwapRouter.TokenInputStruct[],
      data: BytesLike,
      minLiquidity: BigNumberish,
      callback: string,
      callbackData: BytesLike,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<ContractTransaction>;

    addLiquidity2(
      pool: string,
      inputs: SyncSwapRouter.TokenInputStruct[],
      data: BytesLike,
      minLiquidity: BigNumberish,
      callback: string,
      callbackData: BytesLike,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<ContractTransaction>;

    addLiquidityWithPermit(
      pool: string,
      inputs: SyncSwapRouter.TokenInputStruct[],
      data: BytesLike,
      minLiquidity: BigNumberish,
      callback: string,
      callbackData: BytesLike,
      permits: IRouter.SplitPermitParamsStruct[],
      overrides?: PayableOverrides & { from?: string }
    ): Promise<ContractTransaction>;

    addLiquidityWithPermit2(
      pool: string,
      inputs: SyncSwapRouter.TokenInputStruct[],
      data: BytesLike,
      minLiquidity: BigNumberish,
      callback: string,
      callbackData: BytesLike,
      permits: IRouter.SplitPermitParamsStruct[],
      overrides?: PayableOverrides & { from?: string }
    ): Promise<ContractTransaction>;

    burnLiquidity(
      pool: string,
      liquidity: BigNumberish,
      data: BytesLike,
      minAmounts: BigNumberish[],
      callback: string,
      callbackData: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    burnLiquiditySingle(
      pool: string,
      liquidity: BigNumberish,
      data: BytesLike,
      minAmount: BigNumberish,
      callback: string,
      callbackData: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    burnLiquiditySingleWithPermit(
      pool: string,
      liquidity: BigNumberish,
      data: BytesLike,
      minAmount: BigNumberish,
      callback: string,
      callbackData: BytesLike,
      permit: IRouter.ArrayPermitParamsStruct,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    burnLiquidityWithPermit(
      pool: string,
      liquidity: BigNumberish,
      data: BytesLike,
      minAmounts: BigNumberish[],
      callback: string,
      callbackData: BytesLike,
      permit: IRouter.ArrayPermitParamsStruct,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    createPool(
      _factory: string,
      data: BytesLike,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<ContractTransaction>;

    enteredPools(arg0: string, arg1: BigNumberish, overrides?: CallOverrides): Promise<[string]>;

    enteredPoolsLength(account: string, overrides?: CallOverrides): Promise<[BigNumber]>;

    isPoolEntered(arg0: string, arg1: string, overrides?: CallOverrides): Promise<[boolean]>;

    multicall(data: BytesLike[], overrides?: PayableOverrides & { from?: string }): Promise<ContractTransaction>;

    selfPermit(
      token: string,
      value: BigNumberish,
      deadline: BigNumberish,
      v: BigNumberish,
      r: BytesLike,
      s: BytesLike,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<ContractTransaction>;

    selfPermit2(
      token: string,
      value: BigNumberish,
      deadline: BigNumberish,
      signature: BytesLike,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<ContractTransaction>;

    selfPermit2IfNecessary(
      token: string,
      value: BigNumberish,
      deadline: BigNumberish,
      signature: BytesLike,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<ContractTransaction>;

    selfPermitAllowed(
      token: string,
      nonce: BigNumberish,
      expiry: BigNumberish,
      v: BigNumberish,
      r: BytesLike,
      s: BytesLike,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<ContractTransaction>;

    selfPermitAllowedIfNecessary(
      token: string,
      nonce: BigNumberish,
      expiry: BigNumberish,
      v: BigNumberish,
      r: BytesLike,
      s: BytesLike,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<ContractTransaction>;

    selfPermitIfNecessary(
      token: string,
      value: BigNumberish,
      deadline: BigNumberish,
      v: BigNumberish,
      r: BytesLike,
      s: BytesLike,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<ContractTransaction>;

    stake(
      stakingPool: string,
      token: string,
      amount: BigNumberish,
      onBehalf: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    swap(
      paths: IRouter.SwapPathStruct[],
      amountOutMin: BigNumberish,
      deadline: BigNumberish,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<ContractTransaction>;

    swapWithPermit(
      paths: IRouter.SwapPathStruct[],
      amountOutMin: BigNumberish,
      deadline: BigNumberish,
      permit: IRouter.SplitPermitParamsStruct,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<ContractTransaction>;

    vault(overrides?: CallOverrides): Promise<[string]>;

    wETH(overrides?: CallOverrides): Promise<[string]>;
  };

  addLiquidity(
    pool: string,
    inputs: SyncSwapRouter.TokenInputStruct[],
    data: BytesLike,
    minLiquidity: BigNumberish,
    callback: string,
    callbackData: BytesLike,
    overrides?: PayableOverrides & { from?: string }
  ): Promise<ContractTransaction>;

  addLiquidity2(
    pool: string,
    inputs: SyncSwapRouter.TokenInputStruct[],
    data: BytesLike,
    minLiquidity: BigNumberish,
    callback: string,
    callbackData: BytesLike,
    overrides?: PayableOverrides & { from?: string }
  ): Promise<ContractTransaction>;

  addLiquidityWithPermit(
    pool: string,
    inputs: SyncSwapRouter.TokenInputStruct[],
    data: BytesLike,
    minLiquidity: BigNumberish,
    callback: string,
    callbackData: BytesLike,
    permits: IRouter.SplitPermitParamsStruct[],
    overrides?: PayableOverrides & { from?: string }
  ): Promise<ContractTransaction>;

  addLiquidityWithPermit2(
    pool: string,
    inputs: SyncSwapRouter.TokenInputStruct[],
    data: BytesLike,
    minLiquidity: BigNumberish,
    callback: string,
    callbackData: BytesLike,
    permits: IRouter.SplitPermitParamsStruct[],
    overrides?: PayableOverrides & { from?: string }
  ): Promise<ContractTransaction>;

  burnLiquidity(
    pool: string,
    liquidity: BigNumberish,
    data: BytesLike,
    minAmounts: BigNumberish[],
    callback: string,
    callbackData: BytesLike,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  burnLiquiditySingle(
    pool: string,
    liquidity: BigNumberish,
    data: BytesLike,
    minAmount: BigNumberish,
    callback: string,
    callbackData: BytesLike,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  burnLiquiditySingleWithPermit(
    pool: string,
    liquidity: BigNumberish,
    data: BytesLike,
    minAmount: BigNumberish,
    callback: string,
    callbackData: BytesLike,
    permit: IRouter.ArrayPermitParamsStruct,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  burnLiquidityWithPermit(
    pool: string,
    liquidity: BigNumberish,
    data: BytesLike,
    minAmounts: BigNumberish[],
    callback: string,
    callbackData: BytesLike,
    permit: IRouter.ArrayPermitParamsStruct,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  createPool(
    _factory: string,
    data: BytesLike,
    overrides?: PayableOverrides & { from?: string }
  ): Promise<ContractTransaction>;

  enteredPools(arg0: string, arg1: BigNumberish, overrides?: CallOverrides): Promise<string>;

  enteredPoolsLength(account: string, overrides?: CallOverrides): Promise<BigNumber>;

  isPoolEntered(arg0: string, arg1: string, overrides?: CallOverrides): Promise<boolean>;

  multicall(data: BytesLike[], overrides?: PayableOverrides & { from?: string }): Promise<ContractTransaction>;

  selfPermit(
    token: string,
    value: BigNumberish,
    deadline: BigNumberish,
    v: BigNumberish,
    r: BytesLike,
    s: BytesLike,
    overrides?: PayableOverrides & { from?: string }
  ): Promise<ContractTransaction>;

  selfPermit2(
    token: string,
    value: BigNumberish,
    deadline: BigNumberish,
    signature: BytesLike,
    overrides?: PayableOverrides & { from?: string }
  ): Promise<ContractTransaction>;

  selfPermit2IfNecessary(
    token: string,
    value: BigNumberish,
    deadline: BigNumberish,
    signature: BytesLike,
    overrides?: PayableOverrides & { from?: string }
  ): Promise<ContractTransaction>;

  selfPermitAllowed(
    token: string,
    nonce: BigNumberish,
    expiry: BigNumberish,
    v: BigNumberish,
    r: BytesLike,
    s: BytesLike,
    overrides?: PayableOverrides & { from?: string }
  ): Promise<ContractTransaction>;

  selfPermitAllowedIfNecessary(
    token: string,
    nonce: BigNumberish,
    expiry: BigNumberish,
    v: BigNumberish,
    r: BytesLike,
    s: BytesLike,
    overrides?: PayableOverrides & { from?: string }
  ): Promise<ContractTransaction>;

  selfPermitIfNecessary(
    token: string,
    value: BigNumberish,
    deadline: BigNumberish,
    v: BigNumberish,
    r: BytesLike,
    s: BytesLike,
    overrides?: PayableOverrides & { from?: string }
  ): Promise<ContractTransaction>;

  stake(
    stakingPool: string,
    token: string,
    amount: BigNumberish,
    onBehalf: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  swap(
    paths: IRouter.SwapPathStruct[],
    amountOutMin: BigNumberish,
    deadline: BigNumberish,
    overrides?: PayableOverrides & { from?: string }
  ): Promise<ContractTransaction>;

  swapWithPermit(
    paths: IRouter.SwapPathStruct[],
    amountOutMin: BigNumberish,
    deadline: BigNumberish,
    permit: IRouter.SplitPermitParamsStruct,
    overrides?: PayableOverrides & { from?: string }
  ): Promise<ContractTransaction>;

  vault(overrides?: CallOverrides): Promise<string>;

  wETH(overrides?: CallOverrides): Promise<string>;

  callStatic: {
    addLiquidity(
      pool: string,
      inputs: SyncSwapRouter.TokenInputStruct[],
      data: BytesLike,
      minLiquidity: BigNumberish,
      callback: string,
      callbackData: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    addLiquidity2(
      pool: string,
      inputs: SyncSwapRouter.TokenInputStruct[],
      data: BytesLike,
      minLiquidity: BigNumberish,
      callback: string,
      callbackData: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    addLiquidityWithPermit(
      pool: string,
      inputs: SyncSwapRouter.TokenInputStruct[],
      data: BytesLike,
      minLiquidity: BigNumberish,
      callback: string,
      callbackData: BytesLike,
      permits: IRouter.SplitPermitParamsStruct[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    addLiquidityWithPermit2(
      pool: string,
      inputs: SyncSwapRouter.TokenInputStruct[],
      data: BytesLike,
      minLiquidity: BigNumberish,
      callback: string,
      callbackData: BytesLike,
      permits: IRouter.SplitPermitParamsStruct[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    burnLiquidity(
      pool: string,
      liquidity: BigNumberish,
      data: BytesLike,
      minAmounts: BigNumberish[],
      callback: string,
      callbackData: BytesLike,
      overrides?: CallOverrides
    ): Promise<IPool.TokenAmountStructOutput[]>;

    burnLiquiditySingle(
      pool: string,
      liquidity: BigNumberish,
      data: BytesLike,
      minAmount: BigNumberish,
      callback: string,
      callbackData: BytesLike,
      overrides?: CallOverrides
    ): Promise<IPool.TokenAmountStructOutput>;

    burnLiquiditySingleWithPermit(
      pool: string,
      liquidity: BigNumberish,
      data: BytesLike,
      minAmount: BigNumberish,
      callback: string,
      callbackData: BytesLike,
      permit: IRouter.ArrayPermitParamsStruct,
      overrides?: CallOverrides
    ): Promise<IPool.TokenAmountStructOutput>;

    burnLiquidityWithPermit(
      pool: string,
      liquidity: BigNumberish,
      data: BytesLike,
      minAmounts: BigNumberish[],
      callback: string,
      callbackData: BytesLike,
      permit: IRouter.ArrayPermitParamsStruct,
      overrides?: CallOverrides
    ): Promise<IPool.TokenAmountStructOutput[]>;

    createPool(_factory: string, data: BytesLike, overrides?: CallOverrides): Promise<string>;

    enteredPools(arg0: string, arg1: BigNumberish, overrides?: CallOverrides): Promise<string>;

    enteredPoolsLength(account: string, overrides?: CallOverrides): Promise<BigNumber>;

    isPoolEntered(arg0: string, arg1: string, overrides?: CallOverrides): Promise<boolean>;

    multicall(data: BytesLike[], overrides?: CallOverrides): Promise<string[]>;

    selfPermit(
      token: string,
      value: BigNumberish,
      deadline: BigNumberish,
      v: BigNumberish,
      r: BytesLike,
      s: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    selfPermit2(
      token: string,
      value: BigNumberish,
      deadline: BigNumberish,
      signature: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    selfPermit2IfNecessary(
      token: string,
      value: BigNumberish,
      deadline: BigNumberish,
      signature: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    selfPermitAllowed(
      token: string,
      nonce: BigNumberish,
      expiry: BigNumberish,
      v: BigNumberish,
      r: BytesLike,
      s: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    selfPermitAllowedIfNecessary(
      token: string,
      nonce: BigNumberish,
      expiry: BigNumberish,
      v: BigNumberish,
      r: BytesLike,
      s: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    selfPermitIfNecessary(
      token: string,
      value: BigNumberish,
      deadline: BigNumberish,
      v: BigNumberish,
      r: BytesLike,
      s: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    stake(
      stakingPool: string,
      token: string,
      amount: BigNumberish,
      onBehalf: string,
      overrides?: CallOverrides
    ): Promise<void>;

    swap(
      paths: IRouter.SwapPathStruct[],
      amountOutMin: BigNumberish,
      deadline: BigNumberish,
      overrides?: CallOverrides
    ): Promise<IPool.TokenAmountStructOutput>;

    swapWithPermit(
      paths: IRouter.SwapPathStruct[],
      amountOutMin: BigNumberish,
      deadline: BigNumberish,
      permit: IRouter.SplitPermitParamsStruct,
      overrides?: CallOverrides
    ): Promise<IPool.TokenAmountStructOutput>;

    vault(overrides?: CallOverrides): Promise<string>;

    wETH(overrides?: CallOverrides): Promise<string>;
  };

  filters: {};

  estimateGas: {
    addLiquidity(
      pool: string,
      inputs: SyncSwapRouter.TokenInputStruct[],
      data: BytesLike,
      minLiquidity: BigNumberish,
      callback: string,
      callbackData: BytesLike,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<BigNumber>;

    addLiquidity2(
      pool: string,
      inputs: SyncSwapRouter.TokenInputStruct[],
      data: BytesLike,
      minLiquidity: BigNumberish,
      callback: string,
      callbackData: BytesLike,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<BigNumber>;

    addLiquidityWithPermit(
      pool: string,
      inputs: SyncSwapRouter.TokenInputStruct[],
      data: BytesLike,
      minLiquidity: BigNumberish,
      callback: string,
      callbackData: BytesLike,
      permits: IRouter.SplitPermitParamsStruct[],
      overrides?: PayableOverrides & { from?: string }
    ): Promise<BigNumber>;

    addLiquidityWithPermit2(
      pool: string,
      inputs: SyncSwapRouter.TokenInputStruct[],
      data: BytesLike,
      minLiquidity: BigNumberish,
      callback: string,
      callbackData: BytesLike,
      permits: IRouter.SplitPermitParamsStruct[],
      overrides?: PayableOverrides & { from?: string }
    ): Promise<BigNumber>;

    burnLiquidity(
      pool: string,
      liquidity: BigNumberish,
      data: BytesLike,
      minAmounts: BigNumberish[],
      callback: string,
      callbackData: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    burnLiquiditySingle(
      pool: string,
      liquidity: BigNumberish,
      data: BytesLike,
      minAmount: BigNumberish,
      callback: string,
      callbackData: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    burnLiquiditySingleWithPermit(
      pool: string,
      liquidity: BigNumberish,
      data: BytesLike,
      minAmount: BigNumberish,
      callback: string,
      callbackData: BytesLike,
      permit: IRouter.ArrayPermitParamsStruct,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    burnLiquidityWithPermit(
      pool: string,
      liquidity: BigNumberish,
      data: BytesLike,
      minAmounts: BigNumberish[],
      callback: string,
      callbackData: BytesLike,
      permit: IRouter.ArrayPermitParamsStruct,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    createPool(_factory: string, data: BytesLike, overrides?: PayableOverrides & { from?: string }): Promise<BigNumber>;

    enteredPools(arg0: string, arg1: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

    enteredPoolsLength(account: string, overrides?: CallOverrides): Promise<BigNumber>;

    isPoolEntered(arg0: string, arg1: string, overrides?: CallOverrides): Promise<BigNumber>;

    multicall(data: BytesLike[], overrides?: PayableOverrides & { from?: string }): Promise<BigNumber>;

    selfPermit(
      token: string,
      value: BigNumberish,
      deadline: BigNumberish,
      v: BigNumberish,
      r: BytesLike,
      s: BytesLike,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<BigNumber>;

    selfPermit2(
      token: string,
      value: BigNumberish,
      deadline: BigNumberish,
      signature: BytesLike,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<BigNumber>;

    selfPermit2IfNecessary(
      token: string,
      value: BigNumberish,
      deadline: BigNumberish,
      signature: BytesLike,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<BigNumber>;

    selfPermitAllowed(
      token: string,
      nonce: BigNumberish,
      expiry: BigNumberish,
      v: BigNumberish,
      r: BytesLike,
      s: BytesLike,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<BigNumber>;

    selfPermitAllowedIfNecessary(
      token: string,
      nonce: BigNumberish,
      expiry: BigNumberish,
      v: BigNumberish,
      r: BytesLike,
      s: BytesLike,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<BigNumber>;

    selfPermitIfNecessary(
      token: string,
      value: BigNumberish,
      deadline: BigNumberish,
      v: BigNumberish,
      r: BytesLike,
      s: BytesLike,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<BigNumber>;

    stake(
      stakingPool: string,
      token: string,
      amount: BigNumberish,
      onBehalf: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    swap(
      paths: IRouter.SwapPathStruct[],
      amountOutMin: BigNumberish,
      deadline: BigNumberish,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<BigNumber>;

    swapWithPermit(
      paths: IRouter.SwapPathStruct[],
      amountOutMin: BigNumberish,
      deadline: BigNumberish,
      permit: IRouter.SplitPermitParamsStruct,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<BigNumber>;

    vault(overrides?: CallOverrides): Promise<BigNumber>;

    wETH(overrides?: CallOverrides): Promise<BigNumber>;
  };

  populateTransaction: {
    addLiquidity(
      pool: string,
      inputs: SyncSwapRouter.TokenInputStruct[],
      data: BytesLike,
      minLiquidity: BigNumberish,
      callback: string,
      callbackData: BytesLike,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    addLiquidity2(
      pool: string,
      inputs: SyncSwapRouter.TokenInputStruct[],
      data: BytesLike,
      minLiquidity: BigNumberish,
      callback: string,
      callbackData: BytesLike,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    addLiquidityWithPermit(
      pool: string,
      inputs: SyncSwapRouter.TokenInputStruct[],
      data: BytesLike,
      minLiquidity: BigNumberish,
      callback: string,
      callbackData: BytesLike,
      permits: IRouter.SplitPermitParamsStruct[],
      overrides?: PayableOverrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    addLiquidityWithPermit2(
      pool: string,
      inputs: SyncSwapRouter.TokenInputStruct[],
      data: BytesLike,
      minLiquidity: BigNumberish,
      callback: string,
      callbackData: BytesLike,
      permits: IRouter.SplitPermitParamsStruct[],
      overrides?: PayableOverrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    burnLiquidity(
      pool: string,
      liquidity: BigNumberish,
      data: BytesLike,
      minAmounts: BigNumberish[],
      callback: string,
      callbackData: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    burnLiquiditySingle(
      pool: string,
      liquidity: BigNumberish,
      data: BytesLike,
      minAmount: BigNumberish,
      callback: string,
      callbackData: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    burnLiquiditySingleWithPermit(
      pool: string,
      liquidity: BigNumberish,
      data: BytesLike,
      minAmount: BigNumberish,
      callback: string,
      callbackData: BytesLike,
      permit: IRouter.ArrayPermitParamsStruct,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    burnLiquidityWithPermit(
      pool: string,
      liquidity: BigNumberish,
      data: BytesLike,
      minAmounts: BigNumberish[],
      callback: string,
      callbackData: BytesLike,
      permit: IRouter.ArrayPermitParamsStruct,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    createPool(
      _factory: string,
      data: BytesLike,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    enteredPools(arg0: string, arg1: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    enteredPoolsLength(account: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    isPoolEntered(arg0: string, arg1: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    multicall(data: BytesLike[], overrides?: PayableOverrides & { from?: string }): Promise<PopulatedTransaction>;

    selfPermit(
      token: string,
      value: BigNumberish,
      deadline: BigNumberish,
      v: BigNumberish,
      r: BytesLike,
      s: BytesLike,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    selfPermit2(
      token: string,
      value: BigNumberish,
      deadline: BigNumberish,
      signature: BytesLike,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    selfPermit2IfNecessary(
      token: string,
      value: BigNumberish,
      deadline: BigNumberish,
      signature: BytesLike,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    selfPermitAllowed(
      token: string,
      nonce: BigNumberish,
      expiry: BigNumberish,
      v: BigNumberish,
      r: BytesLike,
      s: BytesLike,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    selfPermitAllowedIfNecessary(
      token: string,
      nonce: BigNumberish,
      expiry: BigNumberish,
      v: BigNumberish,
      r: BytesLike,
      s: BytesLike,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    selfPermitIfNecessary(
      token: string,
      value: BigNumberish,
      deadline: BigNumberish,
      v: BigNumberish,
      r: BytesLike,
      s: BytesLike,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    stake(
      stakingPool: string,
      token: string,
      amount: BigNumberish,
      onBehalf: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    swap(
      paths: IRouter.SwapPathStruct[],
      amountOutMin: BigNumberish,
      deadline: BigNumberish,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    swapWithPermit(
      paths: IRouter.SwapPathStruct[],
      amountOutMin: BigNumberish,
      deadline: BigNumberish,
      permit: IRouter.SplitPermitParamsStruct,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    vault(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    wETH(overrides?: CallOverrides): Promise<PopulatedTransaction>;
  };
}
